-- {-# LANGUAGE NoTemplateHaskell #-}
{-# OPTIONS -Wno-missing-export-lists #-}

-- | This module is a clone of @Michelson.Typed.EntryPoints.Sing.Alg.Set@,
-- where getting is replaced with setting
module Michelson.Typed.EntryPoints.Sing.Alg.Set where

-- import Control.Monad.Fail
-- import Data.Either
-- import Data.Bitraversable
-- import Prelude hiding (fail, unwords, show)
-- import GHC.Generics ((:.:)(..))

-- import Data.Either.Run
-- import Data.Either.Run.ErrorMessage

-- import Data.Singletons.TypeLits.Util
-- import Michelson.Typed.Annotation.Path
-- import Michelson.Typed.Annotation.Sing.Alg
-- import Michelson.Typed.EntryPoints.Error
-- import Michelson.Typed.EntryPoints.Sing.Alg.Types
-- import Michelson.Typed.EntryPoints.Sing.Alg.Lens --
-- -- import Michelson.Typed.EntryPoints.Sing.Alg.Paths
-- import Michelson.Typed.T.Alg
-- import Michelson.Typed.Value.Free

-- import qualified Data.Text as T
-- import Data.Singletons
-- import Data.Singletons.TypeError
-- import Data.Singletons.Prelude.Either
-- import Data.Singletons.Prelude.Eq
-- import Data.Singletons.Prelude.Bool

-- setEpFieldTFieldEq :: forall f t fieldNameA fieldNameB eqAB. ()
--   => Sing t
--   -> Sing fieldNameA
--   -> Sing fieldNameB
--   -> Sing eqAB
--   -> RunEither SingError (f :.: ValueOpq) (EpFieldTFieldEq t fieldNameA fieldNameB eqAB)
--   -> (f :.: ValueOpq) t
--   -> (f :.: ValueOpq) t
-- setEpFieldTFieldEq _ _ _ STrue (RunRight xs) _ = xs
-- setEpFieldTFieldEq st sfieldNameA sfieldNameB SFalse _ xss = xss
-- -- RunLeft $ SingError $
-- --   sing :%<>:
-- --   SShowType st :%<>:
-- --   sing :%<>:
-- --   SText sfieldNameA :%<>:
-- --   sing :%<>:
-- --   SText sfieldNameB

-- setEpFieldTAssertHere :: (MonadFail f)
--   => Sing t
--   -> Sing epPath
--   -> Sing xs
--   -> RunEither SingError (f :.: ValueOpq) (EpFieldTAssertHere t epPath xs)
--   -> RunEither SingError (f :.: ValueOpq) xs
-- setEpFieldTAssertHere st sepPath sxs xss =
--   case sxs of
--     SLeft _ -> xss
--     SRight _ ->
--       case sepPath of
--         SHere -> xss
--         ((:%*) _ _) -> RunRight . Comp1 . fail . T.unpack . fromSing $ singEpFieldTAssertHereError singITOpq st sepPath
--         ((:%+) _ _) -> RunRight . Comp1 . fail . T.unpack . fromSing $ singEpFieldTAssertHereError singITOpq st sepPath

-- setEpFieldTEntrypointEq :: forall f t ann epPath fieldName entrypointNameA entrypointNameB eqAB. (MonadFail f)
--   => Sing t
--   -> Sing ann
--   -> Sing epPath
--   -> Sing fieldName
--   -> Sing entrypointNameA
--   -> Sing entrypointNameB
--   -> Sing eqAB
--   -> RunEither SingError (f :.: ValueOpq) (EpFieldTEntrypointEq t ann epPath fieldName entrypointNameA entrypointNameB eqAB)
--   -> (f :.: ValueAlg) t
--   -> (f :.: ValueAlg) t
-- setEpFieldTEntrypointEq t ann' epPath fieldName _ _ STrue xs xss =
--   setEpFieldT t ann' epPath fieldName xs xss
-- setEpFieldTEntrypointEq t ann' epPath fieldName entrypointNameA entrypointNameB SFalse _ _ =
--   Comp1 . fail . T.unpack . fromSing $
--   -- RunLeft $ SingError $
--   singEpFieldTEntrypointError t ann' epPath fieldName entrypointNameA entrypointNameB

-- setEpFieldTResolveOr :: forall f ta tb aa ab as bs epPath fieldName. (MonadFail f)
--   => Sing ta
--   -> Sing tb
--   -> Sing aa
--   -> Sing ab
--   -> Sing as
--   -> Sing bs
--   -> Sing epPath
--   -> Sing fieldName
--   -> RunEither SingError (f :.: ValueOpq) (EpFieldTResolveOr ta tb aa ab as bs epPath fieldName)
--   -> f (Either ((f :.: ValueAlg) ta) ((f :.: ValueAlg) tb))
--   -> f (Either ((f :.: ValueAlg) ta) ((f :.: ValueAlg) tb))
-- setEpFieldTResolveOr ta tb aa ab as bs ((:%+) entrypointName epPath) fieldName xs xss =
--   fromMaybe xss $
--   biRunEitherAppendErrM
--     (singEpFieldTEntrypointEq ta as epPath fieldName aa entrypointName (aa %== entrypointName))
--     (singEpFieldTEntrypointEq tb bs epPath fieldName ab entrypointName (ab %== entrypointName))
--     (\ys -> (setEpFieldTEntrypointEq ta as epPath fieldName aa entrypointName (aa %== entrypointName) ys `first`) <$> xss)
--     (\ys -> (setEpFieldTEntrypointEq tb bs epPath fieldName ab entrypointName (ab %== entrypointName) ys `second`) <$> xss)
--     xs
-- setEpFieldTResolveOr _ _ saa sab sas sbs sepPath@((:%*) _ _) sfieldName xs xss = xss
-- --   RunLeft $ SingError $ singEpFieldTResolveOrError saa sab sas sbs sepPath sfieldName
-- setEpFieldTResolveOr _ _ saa sab sas sbs sepPath@SHere sfieldName _ xss = xss
-- --   RunLeft $ SingError $ singEpFieldTResolveOrError saa sab sas sbs sepPath sfieldName

-- setEpFieldTResolvePair :: forall f ta tb as bs epPath fieldName. (MonadFail f)
--   => Sing ta
--   -> Sing tb
--   -> Sing as
--   -> Sing bs
--   -> Sing epPath
--   -> Sing fieldName
--   -> RunEither SingError (f :.: ValueOpq) (EpFieldTResolvePair ta tb as bs epPath fieldName)
--   -> f ((f :.: ValueAlg) ta, (f :.: ValueAlg) tb)
--   -> f ((f :.: ValueAlg) ta, (f :.: ValueAlg) tb)
-- setEpFieldTResolvePair sta stb sas sbs ((:%*) sepPathA sepPathB) sfieldName xs xss =
--   fromMaybe xss $
--   biRunEitherAppendErrM
--     (singEpFieldT sta sas sepPathA sfieldName)
--     (singEpFieldT stb sbs sepPathB sfieldName)
--     (\ys -> (setEpFieldT sta sas sepPathA sfieldName ys `first`) <$> xss)
--     (\ys -> (setEpFieldT stb sbs sepPathB sfieldName ys `second`) <$> xss)
--     xs
-- setEpFieldTResolvePair _ _ sas sbs sepPath@((:%+) _ _) sfieldName _ xss = xss
-- setEpFieldTResolvePair _ _ sas sbs sepPath@SHere sfieldName _ xss = xss

-- setEpFieldT :: forall f t (ann :: SymAnn t) epPath fieldName. (MonadFail f)
--   => Sing t
--   -> Sing ann
--   -> Sing epPath
--   -> Sing fieldName
--   -> RunEither SingError (f :.: ValueOpq) (EpFieldT t ann epPath fieldName)
--   -> (f :.: ValueAlg) t
--   -> (f :.: ValueAlg) t
-- setEpFieldT (STOr ta tb) (SATOr _ aa ab as bs) epPath fieldName xs (Comp1 xss) =
--   Comp1 $ do
--   VOr xss' <- xss
--   setEpFieldTResolveOr ta tb aa ab as bs epPath fieldName xs (return $ bimap (Comp1 . pure) (Comp1 . pure) xss') >>= either
--     (fmap (VOr . Left) . unComp1)
--     (fmap (VOr . Right) . unComp1)

-- setEpFieldT (STPair ta tb) (SATPair _ _ _ as bs) epPath fieldName xs (Comp1 xss) = Comp1 $
--   (>>= \case { (Comp1 xs', Comp1 ys') -> VPair <$> liftA2 (,) xs' ys' }) $ -- Comp1 . liftA2 (fmap VPair . (,)) xs' ys'
--   setEpFieldTResolvePair ta tb as bs epPath fieldName xs $ return
--   ( Comp1 $ \case { VPair (xs', ys') -> xs' } <$> xss
--   , Comp1 $ \case { VPair (xs', ys') -> ys' } <$> xss
--   )
-- setEpFieldT (STOpq t1) (SATOpq ta) epPath tb xs (Comp1 xss) =
--   Comp1 $
--   fmap VOpq $
--   unComp1 $
--   setEpFieldTFieldEq t1 (singTOpqTypeAnn ta) tb (singTOpqTypeAnn ta %== tb)
--     (setEpFieldTAssertHere t1 epPath
--       (singEpFieldTFieldEq t1 (singTOpqTypeAnn ta) tb (singTOpqTypeAnn ta %== tb))
--       xs
--     ) $
--     Comp1 $
--     \case { VOpq xss' -> xss' } <$> xss

